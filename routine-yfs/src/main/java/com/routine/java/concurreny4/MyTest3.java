package com.routine.java.concurreny4;

/**
 * volatile 主要有三个作用
 * 1、实现long/double类型变量的原子操作
 * 2、防止指令重排序
 * 3、实现变量的可变性
 *
 * 当变量被volatile修饰时，应用就不会从寄存器中读取该变量的值，而是从内存（高速缓存中）获取
 *
 * volatile与锁类似的地方有两点
 * 1、保证变量的内存可见性
 * 2、防止指令重排序
 *
 * volatile可以确保对变量写的原子性，但是不具备排他性
 * 另外一个重要的点在于，使用锁可能会导致线程的上下文切换（内核态与用户态之间的切换），但是用volatile并不会出现这种情况
 *
 * 如果要实现volatile写操作的原子性，那么在等号右侧赋值变量中就不能出现被多线程共享的变量，哪怕这个变量也是被volatile修饰也不行。
 *
 * 防止指令重排序与实现变量的可见性都是通过一种手段来实现的：内存屏障（memory barrier）
 *
 * Release Barrier：防止下面volatile与上面的所有操作的指令重排序
 * Store Barrier：重要作用是刷新处理器缓存，结果是可以确保该存储屏障之前一切的操作结果锁生成的结果对于其他处理器来说都是可见的
 *
 * Load Barrier：可以刷新处理器缓存，同步其他处理器对该volatile变量的修改结果
 * Acquire Barrier：可以防止上面volatile读取操作与下面的所有操作语句指令重排序
 *
 * 对于volatile关键字变量的读写操作，本质上都是通过内存屏障来执行的
 *
 * 内存屏障兼具两方面的能力
 * 1、防止指令重排序
 * 2、实现变量的内存可见性
 *
 * 1、对于读取操作来说，volatile可以确保该操作与其后续的所有读写操作都不会进行指令重排序
 * 2、对于修改操作来说，volatile可以确保该操作与其上面的所有得写操作都不会进行指令重排序
 *
 *
 * volatile与锁的一些比较
 * 锁同样具备变量内存可见性与防治指令重排序的功能
 *
 *
 */
public class MyTest3 {
}
