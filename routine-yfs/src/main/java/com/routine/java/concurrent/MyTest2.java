package com.routine.java.concurrent;

/**
 * 当我们使用synchronized关键字修饰代码块时，字节码层面上是通过monitorenter与monitorexit指令来实现的锁的获取释放动作
 * 当线程进入到monitorenter指令后，线程将会持有monitor对象，退出monitorenter后，monitor将释放monitor对象
 * <p>
 * 对于synchronized关键字修饰方法来说，并没有出现monitorenter和monitorexit指令，而是出现了一个ACC_SYNCHRONIZED标志
 * jvm使用了ACC_SYNCHRONIZED访问标志来区分一个方法是否为同步方法；当方法被调用的时候，调用指令会检查该方法是否拥有ACC_SYNCHRONIZED标志，
 * 如果有，那么执行线程将会先持有方法所在对象的monitor对象，然后再去执行方法体；在该方法执行期间，其他任何线程均无法在获得这个monitor对象，当线程执行完
 * 该方法后，他会释放掉这个monitor对象
 * <p>
 * jvm中的不同是基于进入与退出显示器对象（管程）（monitor）来实现的，每个对象实例都会有一个monitor对象，monitor对象会和java对象一同创建并销毁
 * Monitor对象是由c++实现的。
 * <p>
 * 当多个线程同时访问一段同步代码时，这些线程会被放到一个EntryList集合中，处于阻塞状态的 线程都会被放到该列表当中，接下来，当线程获取到对象的monitor时，
 * monitor是依赖于底层操作系统的mutex lock来实现互斥的，线程获取mutex成功，则会持有该mutex，这时其他线程就无法再获取到该mutex
 * <p>
 * 如果线程调用了wait方法，那么该线程就会释放掉所持有的mutex，并且该线程就会进入到wait set中，等待下一次被其他线程调用notify/notifyAll唤醒。如果当前线程顺利执行
 * 完毕方法，那么他也会释放掉所持有的mutex
 * <p>
 * 同步锁在这种实现方式当中，因为monitor是依赖于底层的操作系统实现，这样就存在用户态域内核态之间的切换，所以会增加性能开销。
 * <p>
 * 通过对象互斥锁的概念来保证共享数据操作的完整性，每个对象都对应于一个可称为【互斥锁】的标记，这个标记用于保证在任何时刻只能有一个线程访问该对象。
 * <p>
 * EntryList域Wait Set中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在linux系统下通过pthread_nutex_lock函数实现的。
 * 线程被阻塞后便会进入到内核调度状态，这会导致系统在用户态与内核态之间来回切换，严重性能锁的性能。
 * <p>
 * 解决上述问题的办法便是自旋，其原理是：当发生对monitor的征用时，弱Onwner能够在很短时间内释放锁，则那些正在征用的线程就可以稍微等待一下，在
 * owner线程释放掉的线程可能会like获取到锁，从而避免系统阻塞。不过，当owner运行时间超过了临界值后，征用线程自旋一段时间后依然无法获取到锁，这时
 * 征用线程则会停止自旋而进入到阻塞状态。
 * 以上总体思想是：先自旋，不成功再进行阻塞，尽量降低则色的可能性，这对那些执行时间很短的代码块来说有极大的性能提升。显然自旋在多处理器上才有意义。
 * <p>
 * 互斥锁的属性：
 * 1、PTHREAD_MUTEX_TIMED_NP:这是属性的默认值，也就是普通锁。当一个线程加锁后，其余请求这把锁的线程将会形成一个等待队列，并且在解锁后按照
 * 优先级获取到锁。这种策略可以确保资源分配的公平性。
 * 2、PTHREAD_MUTEX_RECURSIVE_NP:嵌套锁，允许一个线程对通一把锁成功获取多次，并通过unlock解锁。如果是不通线程请求，则在加锁的线程解锁时重新进行竞争。
 * 3、PTHREAD_MUTEX_ERRORCHECK_NP:检错锁，如果一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同，这样就保证
 * 了当不允许多次加锁时不会出现最简单情况下的死锁。
 * 4、PTHREAD_MUTEX_ADAOTIVE_NP:适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争。
 *
 * 在jdk1.5之前，我们若想实现线程的同步，只能通过synchronized关键字这一种方式达成；底层，java也是通过synchronized关键字来做到数据的原子性维护；
 * synchronized是jvm实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是jvm帮助我们隐式实现的
 *
 * 从jdk1.5开始，并发包引入了Lock锁，Lock同步锁是基于java来实现的，因此锁的获取与释放都是通过java代码实现与控制的，然后synchronized关键字是基于底层操作系统
 * 的Mutex Lock实现的，每次对锁的获取与释放动作都会来带用户态与内核态之间的切换，这种切换会极大增加系统的负担，当并发量较高时，也就是说锁的竞争比较激烈的时候，
 * synchronized锁在性能上的表现就非常差
 *
 * 从jdk1.6开始，synchronized锁的实现发生了很大的变化；jvm引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁、轻量级锁、重量级锁等，从而
 * 减少锁的竞争锁带来的用户态与内核态之间的切换；这种锁的优化实际上是通过java对象头中的标志位来实现的；对于锁的访问与改变实际上都和java对象头息息相关。
 *
 * 从jdk1.6开始，对象实例在堆中都会被划分为三个组成部分：对象头、实例数据与对齐填充
 *
 * 对象头主要也是由三块内容构成：
 * 1、Mark Word
 * 2、指向类的指针
 * 3、数组长度
 * 其中Mark Word（它记录了对象、锁及垃圾回收相关的信息，在64位的jvm中，其长度是64bit）的位信息包括了如下的组成部分：
 * 1、无锁标记
 * 2、偏向锁标记
 * 3、轻量级锁标记
 * 4、重量级锁标记
 * 5、GC标记
 *
 * 对于synchronized锁来说，锁的升级主要都是通过Mark Word中的锁标志位与是否是偏向锁标志来达成的；synchronized关键字锁对应的锁都是先从偏向锁开始，随着锁竞争的升级，逐步演化成
 * 轻量级锁，最后则变成重量级锁。
 *
 * 对于锁的演化来说，他会经历：
 * 无锁 - 偏向锁 - 轻量级锁 - 重量级锁
 *
 * 偏向锁：是针对一个线程来说，它的主要作用是优化同一个线程多次请求一个锁的情况；如果一个synchronized方法被一个线程访问，那么这个方法
 * 所在的对象就会在其Mark Word中将偏向锁进行标记，同时还会有一个字段来存储该线程的id，当这个线程再次访问同一个synchronized方法的时候，
 * 它会检查这个对象的Mark Word的偏向锁标记以及是否指向了其线程id，如果是，那么该线程就无须再去进入管程（Monitor），而是直接进入到该方法体重。
 *
 * 如果是另外一个线程访问这个synchronized方法，情况如下：
 * 偏向锁就会被取消掉。
 *
 * 轻量级锁：
 * 如果一个线程已经取得了当前对象的锁，这时第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此他是偏向锁，而第二个线程在争抢时，会发现
 * 该对象头中的Mark Word已经是偏向锁，但里面存储的线程id并不是自己的，那么他会进行cas，从而获取到锁，这里面存在两个情况
 * 1、获取锁成功：他会直接将Mark Word中的线程id变成自己的，这样该对象依然会保持偏向锁的状态
 * 2、获取锁失败：则表示这时可能会有多个线程同时在尝试争抢该对象的锁，那么这时偏向锁就会升级，升级为轻量级锁
 *
 * 自旋锁：
 * 如果自旋锁失败，那么锁就会进入到重量级锁，在这种情况下，无法获取到锁的线程都会进入到Monitor（即内核态）
 * 自旋最大的特点就是避免了线程从用户态进入到内核态
 *
 * 重量级锁
 * 线程最终从用户态进入到了内核态
 *
 */
public class MyTest2 {
}
